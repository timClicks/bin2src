// SPDX-License-Identifier: Apache-2.0
#![allow(dead_code)]

use std::fmt;
use std::io;
use std::io::prelude::*;

const DEFAULT_LINEWIDTH: usize = 79;

enum Newline {
    Lf,
    CrLf,
}

enum ByteRepr {
    LowerHex,
    UpperHex,
    Decimal,
}

impl fmt::Display for Newline {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Newline::Lf => write!(f, "\n"),
            Newline::CrLf => write!(f, "\r\n"),
        }
    }
}

struct Translation<'t> {
    newline: Newline,
    max_linewidth: usize,

    // Inserted at the beginning of lines generated by during the byte stream translations to source code.
    // Allows implementors to add indentation.
    line_start: &'t str,

    // Inserted before a newline character,
    // to be used to represent a line terminator, such as `\`, which can be handy for
    // escaping the newline character in those languages that require it.
    line_end: &'t str,
    byte_prefix: &'t str, // Inserted just before a byte is converted to source code. Defaults to an empty string.
    byte_repr: ByteRepr,
    byte_suffix: &'t str, // Inserted after a byte has been converted to source code. Defaults to an empty string.
    prologue_pre_variable: &'t str,
    variable: &'t str,
    prologue_post_variable: &'t str,
    epilogue: &'t str,
}

impl <'t>Default for Translation<'t> {
    fn default() -> Self {
        Translation {
            newline: Newline::Lf,
            max_linewidth: DEFAULT_LINEWIDTH,
            line_start: "",
            line_end: "",

            byte_prefix: "",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",

            prologue_pre_variable: "",
            variable: "DATA",
            prologue_post_variable: "",
            epilogue: "",
        }
    }
}

impl <'t>Translation<'t> {
    fn lower_hex() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            ..Default::default()
        }
    }

    fn upper_hex() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::UpperHex,
            ..Default::default()
        }
    }

    fn rust() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",
            line_start: "    ",
            line_end: "\\",
            prologue_pre_variable: "const ",
            prologue_post_variable: ": &[u8] = b\"",
            epilogue: "\";",
            ..Default::default()
        }
    }
}

#[inline]
fn write_upper_hex<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:02X}{}", prefix, byte, suffix)
}

#[inline]
fn write_lower_hex<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:02x}{}", prefix, byte, suffix)
}

#[inline]
fn write_decimal<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:03}{}", prefix, byte, suffix)
}

type ByteFormatter<W> = fn(&mut W, &str, u8, &str) -> io::Result<()>;

#[inline]
fn write_byte<W: Write>(formatter: ByteFormatter<W>, out: &mut W, prefix: &str, byte: u8, suffix: &str) -> io::Result<()> {
    (formatter)(out, prefix, byte, suffix)
}

fn translate<W: Write, R:Read>(template: &Translation, binary: R, out: &mut W) -> io::Result<()> {
    let (formatter, byte_repr_width): (ByteFormatter<W>, usize) = match template.byte_repr {
        ByteRepr::LowerHex => (write_lower_hex, 2),
        ByteRepr::UpperHex => (write_upper_hex, 2),
        ByteRepr::Decimal => (write_decimal, 3),
    };
    let per_byte = template.byte_prefix.len() + byte_repr_width + template.byte_suffix.len();
    let max_linewidth = template.max_linewidth - template.line_end.trim_end().len();

    let mut prologue = String::with_capacity(max_linewidth);
    prologue.push_str(template.prologue_pre_variable);
    prologue.push_str(template.variable);
    prologue.push_str(template.prologue_post_variable);
    let mut line_length = prologue.len();
    write!(out, "{}", prologue)?;

    for byte in binary.bytes() {
        if line_length + per_byte > max_linewidth {
            write!(out, "{}{}{}", template.line_end, template.newline, template.line_start)?;
            line_length = template.line_start.len();
        }

        write_byte(formatter, out, template.byte_prefix, byte.unwrap(), template.byte_suffix)?;
        line_length += per_byte;
    }
    write!(out, "{}", template.epilogue)?;

    Ok(())
}

fn main() {
    use std::env;
    let stdin = io::stdin();
    let stdin = stdin.lock();
    let mut stdout = io::stdout();

    let variable: String = env::args().nth(1).unwrap_or_else(|| String::from("DATA"));

    let mut translation = Translation::rust();
    translation.variable = &variable;
    translate(&translation, stdin, &mut stdout).unwrap_or_else(|err| { eprintln!("error: {}", err) });

    println!();
}
