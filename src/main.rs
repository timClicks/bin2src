// SPDX-License-Identifier: BlueOak-1.0.0
#![allow(dead_code)]

//! `bin2src` converts a stream of bytes into source code. The intention is to simplify embedding binary data 
//! into your programs.
//! 
//! The following programming languages are supported:
//!  - Rust
//!  - Plain text (base 64 encoded output)
//!  
//! ## Usage
//! 
//! ```
//! $ echo bin2src
//! ```
//! 
//!  At this stage, there is limited support for accessing its functionality from within

#[macro_use]
extern crate clap;
//#[macro_use]
extern crate structopt;

use std::fmt;
use std::io;
use std::io::prelude::*;
use std::path::PathBuf;
use structopt::StructOpt;

const DEFAULT_LINEWIDTH: usize = 79;

enum Newline {
    Lf,
    CrLf,
}

#[derive(PartialEq, Eq)]
pub enum ByteRepr {
    LowerHex,
    UpperHex,
    Decimal,
}

impl fmt::Display for Newline {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Newline::Lf => write!(f, "\n"),
            Newline::CrLf => write!(f, "\r\n"),
        }
    }
}

pub struct Translation<'t> {
    newline: Newline,
    max_linewidth: usize,

    // Inserted at the beginning of lines generated by during the byte stream translations to source code.
    // Allows implementors to add indentation.
    line_start: &'t str,

    // Inserted before a newline character,
    // to be used to represent a line terminator, such as `\`, which can be handy for
    // escaping the newline character in those languages that require it.
    line_end: &'t str,
    byte_prefix: &'t str, // Inserted just before a byte is converted to source code. Defaults to an empty string.
    byte_repr: ByteRepr,
    byte_suffix: &'t str, // Inserted after a byte has been converted to source code. Defaults to an empty string.
    prologue_pre_variable: &'t str,
    variable: &'t str,
    prologue_post_variable: &'t str,
    epilogue: &'t str,
}

impl <'t>Default for Translation<'t> {
    fn default() -> Self {
        Translation {
            newline: Newline::Lf,
            max_linewidth: DEFAULT_LINEWIDTH,
            line_start: "",
            line_end: "",

            byte_prefix: "",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",

            prologue_pre_variable: "",
            variable: "DATA",
            prologue_post_variable: "",
            epilogue: "",
        }
    }
}

impl <'t>Translation<'t> {
    fn lower_hex() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            variable: "",
            ..Default::default()
        }
    }

    fn upper_hex() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::UpperHex,
            variable: "",
            ..Default::default()
        }
    }

    fn rust() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",
            line_start: "    ",
            line_end: "\\",
            prologue_pre_variable: "const ",
            prologue_post_variable: ": &[u8] = b\"",
            epilogue: "\";",
            ..Default::default()
        }
    }

    fn python() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",
            prologue_post_variable: " = \"\"\"",
            epilogue: "\"\"\"",
            ..Default::default()
        }
    }

    fn go() -> Self {
        Translation {
            byte_prefix: "\\x",
            byte_repr: ByteRepr::LowerHex,
            byte_suffix: "",
            prologue_post_variable: " := []byte(`",
            epilogue: "`)",
            ..Default::default()
        }
    }
}

#[inline]
fn write_upper_hex<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:02X}{}", prefix, byte, suffix)
}

#[inline]
fn write_lower_hex<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:02x}{}", prefix, byte, suffix)
}

#[inline]
fn write_decimal<W: Write>(out: &mut W, prefix: &str, byte:u8, suffix: &str) -> io::Result<()>  {
    write!(out, "{}{:03}{}", prefix, byte, suffix)
}

type ByteFormatter<W> = fn(&mut W, &str, u8, &str) -> io::Result<()>;

#[inline]
pub fn write_byte<W: Write>(formatter: ByteFormatter<W>, out: &mut W, prefix: &str, byte: u8, suffix: &str) -> io::Result<()> {
    (formatter)(out, prefix, byte, suffix)
}

fn translate<W: Write, R:Read>(template: &Translation, binary: R, out: &mut W) -> io::Result<()> {
    let (formatter, byte_repr_width): (ByteFormatter<W>, usize) = match template.byte_repr {
        ByteRepr::LowerHex => (write_lower_hex, 2),
        ByteRepr::UpperHex => (write_upper_hex, 2),
        ByteRepr::Decimal => (write_decimal, 3),
    };
    let per_byte = template.byte_prefix.len() + byte_repr_width + template.byte_suffix.len();
    let max_linewidth = template.max_linewidth - template.line_end.trim_end().len();

    let mut prologue = String::with_capacity(max_linewidth);
    prologue.push_str(template.prologue_pre_variable);
    prologue.push_str(template.variable);
    prologue.push_str(template.prologue_post_variable);
    let mut line_length = prologue.len();
    write!(out, "{}", prologue)?;

    for byte in binary.bytes() {
        if line_length + per_byte > max_linewidth {
            write!(out, "{}{}{}", template.line_end, template.newline, template.line_start)?;
            line_length = template.line_start.len();
        }

        write_byte(formatter, out, template.byte_prefix, byte.unwrap(), template.byte_suffix)?;
        line_length += per_byte;
    }
    write!(out, "{}", template.epilogue)?;

    Ok(())
}

arg_enum! {
    #[derive(Debug, Eq, PartialEq)]
    enum OutputFormat {
        Rust,
        Python,
        PlainText,
        Go,
    }
}

arg_enum! {
    #[derive(Debug, Eq, PartialEq)]
    enum Choice {
        Yes,
        No
    }
}

#[derive(StructOpt, Debug)]
#[structopt(rename_all = "kebab-case", raw(setting = "structopt::clap::AppSettings::ColoredHelp", setting = "structopt::clap::AppSettings::ColorAuto"))]
/// Converts a stream of bytes into source code to facilitate embedding binary data 
/// into your programs.
struct Opts {
    #[structopt(short = "f", long = "output", default_value = "plaintext", raw(possible_values = r#"&["plaintext", "go", "rust", "python"]"#, case_insensitive = "true"), name = "format")]
    /// Format that the incoming bytes will be converted into.
    output_format: OutputFormat,

    /// Variable name used within the source code (ignored for PlainText)
    /// 
    /// <a> should be a valid identifier within the <output-format>
    /// language.
    ///
    #[structopt(short = "a", long, default_value = "DATA", name = "a")]
    variable: String,

    #[structopt(long)]
    no_trailing_newline: bool,

    #[structopt(long)]
    upper_case: bool,

    #[structopt(long, short = "w", default_value = "79", name = "width")]
    /// constrains output to <width> characters
    max_linewidth: usize,

    #[structopt(long, parse(from_os_str), default_value = "-")]
    /// file to read byte stream from (- will be converted to read from stdin)
    from: PathBuf,

    #[structopt(long, parse(from_os_str), default_value = "-")]
    /// file to write output to (- will be converted to read from stdin)
    to: PathBuf,
}

fn main() {
    //use std::env;
    let stdin = io::stdin();
    let stdin = stdin.lock();
    let stdout = io::stdout();

    let opts = Opts::from_args();

    let mut translation = match opts.output_format {
        OutputFormat::Rust => Translation::rust(),
        OutputFormat::PlainText => Translation::lower_hex(),
        OutputFormat::Python => Translation::python(),
        OutputFormat::Go => Translation::go(),
    };

    translation.max_linewidth = opts.max_linewidth;

    if !opts.variable.is_empty() && opts.output_format != OutputFormat::PlainText {
        translation.variable = &opts.variable 
    };

    if opts.upper_case && translation.byte_repr == ByteRepr::LowerHex {
        translation.byte_repr = ByteRepr::UpperHex
    };

    let source: Box<Read> = match opts.from.to_str() {
        None => Box::new(stdin),
        Some("-") => Box::new(stdin),
        Some("") => Box::new(stdin),
        Some(input_file) => {
            let f = std::fs::File::open(input_file).expect("unable to open <from>");
            Box::new(f)
        }
    };

    let mut destination: Box<Write> = match opts.to.to_str() {
        None => Box::new(stdout),
        Some("-") => Box::new(stdout),
        Some("") => Box::new(stdout),
        Some(output_file) => Box::new(std::fs::File::open(output_file).expect("unable to open <to>"))
    };

    translate(&translation, source, &mut destination).unwrap_or_else(|err| {
         eprintln!("error: {}", err)
    });

    if !opts.no_trailing_newline {
        println!();
    }
}
